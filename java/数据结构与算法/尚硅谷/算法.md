## 递归

* 实现n的阶乘
* 实现迷宫问题
* 实现八皇后问题（回溯算法）

## 排序

### 时间复杂度

即时间频度，执行语句的次数，时间复杂度由低到高
* 常数阶O(1)
* 对数阶O(log2(n))
* 线性阶O(n)
* 线性对数阶O(n*log2(n))
* 平方阶O(n^2)
* 立方阶O(n^3)
* k次方阶O(n^k)
* 指数阶O(2^n)

### 冒泡排序

每次比较相邻的两个数，如果是逆序，就交换位置
* 实现冒泡排序
* 优化1，当一次循环没有发生交换，排序结束
* 优化2，一次获得最大值和最小值
* 1和2组合

### 选择排序

每次搜索数组剩余数中最小的元素，并与开头位置交换
* 实现快速排序
* 一次获得最大值和最小值

### 插入排序

一个数组分为有序表和无序表，无序表的元素插入有序表中
第一次有序表1个元素，无序表n-1个元素，无序表元素慢慢往有序表移动
缺点：存在最差情况，每个相邻元素都会移动一次
* 实现插入排序

### 希尔排序

对插入排序优化，选择步长array.length/2
第一次每两个元素一组，进行插入排序，这两个元素有步长间隔，不是相邻元素
第二次步长为上一次步长/2，以这个步长组成的元素做插入排序，以此类推
最后一次步长为1，做最后一次插入排序
* 实现希尔排序(交换式，移位式)

### 快速排序

选择中间值作为基准，比这个值小放左边，比这个值大方右边，然后左右两边分别再做快速排序
* 实现快速排序

## 归并排序

分：将数组分成两个部分，这两个部分继续等分，只等都是一个元素的子序列
治：单个元素子序列比较大小排序并合并，以此类推直到归并结束。
* 实现归并排序

## 基数排序

1.将所有数据设置为相等长度的数，前面用0补充
2.从个位数开始，根据个位数放入对应索引的桶中，最后按照桶的顺序取出数据
3.然后从十位，百位依次类推，最后从桶中取出来的数据就是有序的
注意，正常的基数排序无法处理负数
* 实现基数排序
* 实现有负数的基数排序

## 查找

### 顺序(线性)查找
* 实现线性查找
### 二分查找
必须是有序数组
二分索引公式：int mid = (left + right)/2 = left + (right - left)/2
* 实现二分查找
* 实现二分查找有重复的数据
### 插值查找
插值查找与二分查找类似，区别在于索引公式
插值索引公式：int mid = left + (right - left) * (findVal - arr[left]) / (arr[right] - arr[left])
* 实现插值查找
* 实现插值查找有重复的数据
### 斐波那契查找
斐波那契查找与二分查找类似，区别在于索引公式
斐波那契索引公式：int mid = left + F(k-1)-1  其中：F(k) = F(k-1)+F(k-2), 即F(k)-1 = F(k-1)-1+F(k-2)-1 +1 = length
* 实现斐波那契查找
* 实现斐波那契查找有重复的数据